# 隐式构造函数

## 隐式复制构造函数

有些细心的读者可能发现，按值传递参数是非常常见的场景，也就是说调用复制构造函数应当是经常发生的事情。但我们之前写的结构体从来没有声明过复制构造函数呀？
```cpp
// 我们已经有的 String 结构体，并没有声明复制构造函数
struct String {
    String();
    String(const char* initVal);
    String(unsigned num, char c);
    assign(String s);
    length();

    char* str;
private:
    unsigned len;
};
void printStr(String s) {
    std::cout << s.str << std::endl;
}
int main() {
    String a(5, 'x');
    printStr(a); // 理应调用复制构造函数，但复制构造函数在哪儿呢？
}
```

上面这段代码是能够成功编译而且结果看上去没有问题。但是问题就在于，为什么 `printStr` 能够在没有复制构造的情形下复制 `String` 类型的变量呢？

答案就是，当我们没有定义复制构造函数时，编译器会自动为我们生成一个。这个自动生成的复制构造函数称为**隐式复制构造函数**。

<h6 id="idx_复制初始化"></h6>

这个编译器生成的隐式复制构造函数做的事情很简单——就是依次对每个成员都**复制初始化（Copy initialization）**。复制初始化是指：如果是基础数据类型，则直接复制过去；如果是结构体类型，则调用它的复制构造函数。形象地说，就是：
```cpp
struct B { /* 定义略 */ };
struct A {
    int a;
    B b;
    // [...]
    // 下面是编译器生成的隐式复制构造：
    A(const A& rhs) {
        /* 用 rhs.a 初始化成员 a ，直接复制过去*/;
        /* 用 rhs.b 初始化成员 b ，通过调用 B 的复制构造函数 */;
        /* 依次复制初始化其它的所有成员 ... */;
    }
};
```

> 我这里不写 `a = rhs.a;`，`b = rhs.b;` 是因为这是赋值语句，它和初始化有着本质上的不同。

所以说，隐式复制构造函数是一个非常简单的逻辑，就是：如果想把整体复制过来，那就把每一个部分都复制过来就好。

最后请注意编译器何时会做这个操作：当你没有定义形如 `T(T&);` 或者 `T(const T&);` 的构造函数时，编译器会为你生成形如 `T(const T&);` 的隐式复制构造函数。

> 如果其中某一个成员（设其类型为 `M`）只定义形如 `M(M&);` 这样不带 `const` 限定的复制构造函数，那么编译器会转而生成 `T(T&);` 类型的隐式复制构造而非带 `const` 限定版本的（因为这样会编译错误：无法把非只读引用绑定到只读变量上）。

## 隐式默认构造函数

<h6 id="idx_默认构造函数"></h6>

编译器除了会“画蛇添足”地为你添上隐式复制构造函数，有时还会添上叫做“隐式默认构造函数”的东西。为了理解这个概念，我们先来介绍**默认构造函数（Default constructor）**是什么意思——其实很简单，就是无参构造函数：
```cpp
struct S {
    // 就这个
    S() { }
};
```
正因为调用无参构造函数的特殊性（无需初始化器），所以它有了这样一个特殊的名字。那么隐式默认构造函数就是说：编译器会在某些情形时为你自动生成一个默认（无参）构造函数。请看例子：
```cpp
// 我没有为 S 定义任何构造函数
struct S {
    int data;
};
int main() {
    S sth; // 调用默认（无参）构造函数
}
```
这段代码在之前几章可以说是理所当然的，但是我们现在回过头来看一下：`S sth;` 这句话应当调用 `S` 的默认构造函数，但是我们并没有定义。而当你没有定义默认构造函数时，编译器会生成一个**隐式默认构造函数**。一般情况下，它所做的事情也很简单：依次将每个成员都零初始化。对于基础数据类型，零初始化就是初始化为零值，这个我们已经[有所了解](ch04/array/array_init#idx_零初始化)了；而对于结构体类型，零初始化就是调用它的默认构造函数。形象地说：
```cpp
struct B { /* 定义略 */ };
struct A {
    int a;
    B b;
    // [...]
    // 下面是编译器生成的隐式默认构造：
    A() {
        /* 零初始化成员 a ，即初始化为 0 */;
        /* 零初始化成员 b ，通过调用 B 的默认构造函数 */;
        /* 依次零初始化其它的所有成员 ... */;
    }
};
```

> 这里零初始化的含义和标准里零初始化的含义并不相同。对于结构体类型，这种调用默认构造函数的行为称为默认初始化。但本书为了简便起见，统称为“零初始化”。
> 
> 如果写了[默认成员初始化器](ch06/assignment_vs_construct.md#默认成员初始化器)，则隐式默认构造并不零初始化它。详见后续章节。

最后请注意编译器何时会做这个操作：当你没有定义**任何**构造函数时，编译器会为你生成形如 `T();` 的隐式默认构造函数。

## 总结

可以注意到，这两种编译器自动生成的构造函数有相似也有不同。下面的表格做了一些整理：

| 构造函数类型     | 声明形式       | 何时生成                       | 行为                                           |
| ---------------- | -------------- | ------------------------------ | ---------------------------------------------- |
| 隐式复制构造函数 | `T(const T&);` | 没有定义其它**复制**构造函数时 | 复制初始化所有成员（调用复制构造或直接复制）   |
| 隐式默认构造函数 | `T();`         | 没有定义**任何**构造函数时     | 零初始化所有成员（调用默认构造或初始化为零值） |

最后我介绍两种写法：`=default` 和 `=delete`。

`=default` 表示，这个构造函数就按照隐式生成的来就行。用例：
```cpp
struct S {
    // 我不想自己写默认构造函数，就按照隐式生成的来就行
    S() = default;
    // 我也不想自己写复制构造函数，就按照隐式生成的来就行
    S(const S&) = default;

    S(/* 其它构造函数 */) { /* [...] */ }
};
```

换句话说，`=default` 强制编译器生成隐式构造函数，忽略之前所说的生成时机。

`=delete` 表示，不要隐式生成这个构造函数。用例：
```CPP
struct S {
    // 不许生成隐式默认构造函数
    S() = delete;
};
int main() {
    S sth; // 错误：找不到对应的构造函数
}
```
```CPP
struct S {
    S() { }
    // 不许生成隐式复制构造函数
    S(const S&) = delete;
};
void f(S a) { }
int main() {
    S sth;
    f(sth); // 错误：找不到复制构造函数
}
```

换句话说，`=delete` 强制编译器**不**生成隐式构造函数，忽略之前所说的生成时机。
