# 移动语义与智能指针

接下来这一部分内容，是现代 C++ 中非常重要的一环，但也是非常难以理解的部分。我会尽量把它讲明白，但也有可能讲不明白。

C++11 引入了**移动语义**（Move semantic）。这里的“移动”是相对于“复制”的意思。在第五、六章中我很详细地讲解了复制构造函数和复制赋值运算符重载；这两个函数的作用都是将一个对象复制成两个，类似于文本编辑里的“复制”-“粘贴”。而这里的移动语义则是“剪切”-“粘贴”：当调用“移动构造函数”或者“移动赋值运算符重载”时，原有的对象被“剪切”，“粘贴”到新的对象。

刚刚我尽量形象地描述了移动语义的含义，但实现移动语义则需要很多前置知识，所以我要在后面几节一点点展开。首先要重申的第一个概念是值类别：

任何表达式都有一个值类别；换而言之，一个表达式要么是左值，要么是右值。之前我是这样介绍的，可以取地址的表达式为左值，反之为右值；这样说是有失偏颇的，因为标准文本是反过来定义的：左值可以取地址，右值不可以取地址。换而言之，可否取地址不是左右值的定义，而是它的性质。那么左右值的定义到底是什么呢？

这个问题目前我无法给出答案，但我可以给出答案的是两个不同的概念：**泛左值**（glvalue）和**纯右值**（prvalue）。泛左值是指，**具有身份**（Has identity）的表达式。反之，纯右值是没有身份（No identity）的表达式。

这个定义是 C++ 之父 Stroustrup 提出的，是我认为最好理解的一种描述方式——但还是略抽象。什么叫“身份”？我把它翻译为“可识别为独一无二实体”的性质。比如中国居民，每个居民都持有独一无二的身份证，我可以通过身份证确定两个称呼是否指代同一个人，因此中国居民是有身份的。回到编程的话题上，下面的代码中

```cpp
int main() {
    int x{42};
    int y{42};
    x; // 表达式 1
    y; // 表达式 2
}
```

的这两个表达式都是有身份的，也就是泛左值表达式。因为，`x` 这个表达式和 `y` 这个表达式指代的并不是同一实体：一个指代变量 `x`，另一个指代变量 `y`。尽管它们类型相同，甚至在运行时具有相同的值，但由于身份不同，我不可能认为对 `x` 表达式操作和对 `y` 表达式操作是等价行为。反之，下面这段代码

```cpp
int main() {
    42; // 表达式 1
    40 + 2; // 表达式 2
}
```

这里的两个表达式都不具有身份，因此它们都是纯右值表达式。为什么说它们没有身份？因为除了外观以外，我无法区分 `42` 和 `40 + 2` 这两个表达式。`42` 作为操作数和 `40 + 2` 作为操作数的效果肯定是一致的，用它们来初始化变量的效果肯定也没有区别。

我们换一个角度讨论这个问题。从泛左值和纯右值的作用来看：
- 泛左值表达式总是指代一个“实体”，可能是对象（变量）或函数等等；
- 纯右值表达式就是一个“裸”的表达式，它本身没有任何意义。只有当纯右值用作初始化器，或者作为运算符的操作数时，它才发挥作用。

> 这个定义是 C++17 “通过简化值类别以实现可靠的复制消除”提案（[P0135(https://wg21.link/p0135)）提出的，接近现行 C++ 标准中的描述。

由于泛左值表达式指代实体，而每个实体都具有身份（以表明它们是否是相同或不同实体）。而纯右值就像没有求值的数学公式一样，只有在被求值（也就是初始化别人/用作操作数）的那一刻才有用。对于它们来说是否是相同身份不重要，因此没有必要具有身份。

::: tip
\[TODO\] 例子
:::

泛左值、纯右值这一对概念和之前提到的左值、右值概念非常接近。大部分泛左值就是左值，而纯右值表达式必然是右值。两者之间的差异在于**亡值**（xvalue）：亡值是泛左值，但它是右值。这太奇怪了，但正因为有亡值的存在，移动语义才能诞生。我这里就先不讲了，之后再慢慢展开。

![值类别](https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/images/value-categories.png)
