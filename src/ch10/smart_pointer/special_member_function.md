# 特殊成员函数

特殊成员函数是一种约定俗成的说法，一般指编译器会自行生成的那些预置成员函数。这些函数包括默认构造函数、析构函数、复制/移动构造函数和复制/移动赋值运算符重载。

> 此外，还包括[预置比较运算符](../../ch11/advanced/defaulted_compare.md)。

讨论这些预置函数生成的时机是很复杂的。首先我列出下面的表格：这包括了之前在[第五章](../../ch05/defaulted_constructor.md)讨论过的默认构造和复制构造/赋值重载。

| 函数          | 何时隐式预置                            | 何时弃置（`=delete`）<sup>1</sup> |
| ------------- | --------------------------------------- | --------------------------------- |
| 默认构造函数  | 用户未声明**任何**构造函数              |                                   |
| 析构函数      | 用户未声明析构函数                      |                                   |
| 复制构造函数  | 用户未声明 *三之原则* <sup>1</sup> 之一 | 用户声明了“移动语义”              |
| 复制赋值重载  | 用户未声明 *三之原则* <sup>1</sup> 之一 | 用户声明了“移动语义”              |
| 移动构造函数  | 用户未声明 *五之原则* <sup>2</sup>之一  |                                   |
| 移动赋值重载  | 用户未声明 *五之原则* <sup>2</sup>之一  |                                   |
| `operator<=>` |                                         |                                   |
| `operator==`  | `operator<=>` 是预置的                  |                                   |

> 1. 这一列总是包括基类或成员对应特殊函数被弃置或不可访问。
> 2. 三之原则：析构函数、复制构造、复制赋值。
>   - 这与第五章提到的规则有所出入。事实是，若用户声明了析构函数或复制赋值，编译器仍会预置复制构造函数，但这是被弃用的语法；
>   - 同理，若用户声明了析构函数或复制构造，编译器仍会预置复制赋值重载，但这是被弃用的语法。
>   - 总之，若用户声明了 *三之原则* 之一的函数，则编译器要么不会预置，要么预置但不推荐使用。
> 3. 五之原则：析构函数、复制构造、复制赋值、移动构造、移动赋值。

其中 `operator<=>` 和 `operator==` 的预置是之后章节要讲的，现在先不用管。表格前四行是第五章已经了解过的，只是这里用“三之原则”概括性地总结了。那么剩下的就是新鲜内容了：一是增加了因用户定义移动语义而弃置复制构造/赋值，二是预置的移动构造/赋值。

首先来了解预置的移动构造和移动赋值都做了什么。对于移动构造，隐式生成的函数体就是将实参中的各个基类和成员移动构造当前对象的各个基类和成员。对于移动赋值，同理移动赋值各个基类和成员。在代码上，就体现为 `std::move` 已有对象的成员，使得 `operator=` 或构造函数调用接收右值的重载。

```cpp
struct A {};
struct B {
    int a;
    A b;
    // [...]

    // 下为编译器预置的移动构造函数
    B(B&& b): a{std::move(b.a)}, b{std::move(b.b)} /* [...] */ {}

    // 下为编译器预置的移动赋值重载
    B& operator=(B&& rhs) {
        a = std::move(rhs.a);
        b = std::move(rhs.b);
        // [...]
        return *this;
    }
}
```

需要注意的是，预置移动构造/赋值是非常平凡的。它的定义和我们之前的 `String` 或 `UniquePtr` 都不一样——这两个的移动是不平凡的，它们需要进行所有权转移。而平凡的移动构造不会帮我们做这件事。如果我们的 `String` 或 `UniquePtr` 用了预置的移动构造/赋值，那就会导致如“浅拷贝”、所有权不唯一等错误。这些预置函数的作用仅仅是保证成员或基类的移动语义。比如：

```cpp
#include <memory>
#include <string>

struct S {
    // std::string 和 std::unique_ptr 都拥有移动语义
    std::string a;
    std::unique_ptr<int> b;

    // 那么下面这些预置函数保证：
    // S 类型对象被移动时，成员 a 和 b 也被正确移动
    S(S&&) = default;
    S& operator=(S&&) = default;
}
```

那么什么时候编译器会帮我们生成这些预置函数的定义呢？首先第一个前提是所有成员都可以被移动，其次就是用户没有手动定义“五之原则”中的任何一个函数。

## 五之原则

