# C 中的链接

不同于 C++，C 在链接方面有一些语法是不同的，它们在一定程度上让问题更加复杂化。

## 显著区别

在[需要注意的 C 特性](ch04/compare_with_c/c_feature)中，我提到了 C 里只读变量拥有**外部连接**而非内部连接。所以，在 C 中符号连接的问题变得更加简单：它总默认是外部连接的。

C 没有命名空间，更没有匿名命名空间。所以，将 C 中名字声明为内部连接只有一种形式：用 `static` 修饰。

C 没有类的成员函数，也没有静态成员。这简化了我们后续的讨论。

## 试探性定义

在 C++ 中，这样的声明：
```cpp
int a;
```
是变量 `a` 的定义，且是外部连接的。但在 C 中，问题变得复杂：C 称不带初始化器且不带 `static` 或 `extern` 的全局变量声明为**试探性定义（Tentative definition）**。

试探性定义的特点是它**有时仅是声明，而有时又是定义**。如同物理学中的量子，同时表现为波和粒子，仅仅取决于你观测的方式。

当试探性定义与一个同名的“正常定义”同时出现时，则试探性定义成为声明。如果始终没有同名的“正常定义”，则这些试探性定义中某一个成为定义，其余成为声明。

> 在标准中，上文“同时出现”的范围是同一个翻译单元内。但在某些实现（如 Linux 下的 ELF 格式）中，“同时出现”的范围可以是多个翻译单元。也就是说在这种实现下，若翻译单元 a 中含有试探性定义却不带“正常”定义，翻译单元 b 中带“正常定义”，在链接时会将 a 中的试探性定义视为声明。
> 
> 在上述 ELF 实现下，称“正常定义”的符号为强符号，试探性定义的符号为弱符号。在链接时，强符号只能出现一次（对应单一定义原则）；多个弱符号可伴随一个强符号同时链接（这些弱符号——试探性定义——退化为声明）；没有强符号的多个弱符号中，挑选其中一个为定义。

比如一个试探性定义和一个“正常定义”同时出现时，试探性定义退化为声明：
```c
int a;     /* 试探性定义，退化为声明 */
int a = 0; /* “正常定义” */
```
这不违反单一定义原则。又比如多个试探性定义：
```c
int a; /* 试探性定义 */
int a; /* 试探性定义 */
```

## 名字重整与语言连接



?> [TODO]