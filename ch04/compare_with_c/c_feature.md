# 需要注意的 C 特性

?> [TODO] 详细解释

## 独有特性

首先列举 C 中特有而 C++ 中没有的语法。

### 从 `void*` 到其它指针类型的隐式转换

在 C++ 中，允许从任意指针类型 `T*` 到 `void*` 的隐式转换，但反过来不行。但是 C 中允许双向的转换。这使得以下代码
```c
// 申请 sizeof(int) 这么多字节的内存，并将其地址初始化于 p
int* p = malloc(sizeof(int));
```
得以正确编译。因为 `malloc` 是返回 `void*` 的函数，然后 `void*` 可以隐式转换到 `int*`。如果在 C++ 中，你需要加上显式转换才能编译通过：
```cpp
int* p = (int*)malloc(sizeof(int));
```

### 从 `int` 到枚举类型的隐式转换

?> [TODO] 枚举类型

C++ 中允许从枚举类型到其基类型（一般是 `int`）的隐式转换，但反过来不行。C 则允许双向的转换：
```c
enum Color {
    Red,
    Green,
    Blue
};
int a = Red; // C/C++ 都合法
enum Color b = 1; // C 合法，C++ 错误
```

### 无初始化器的只读变量

在 C 中，只读变量可以没有初始化器，然而在 C++ 中这是不允许的。
```c
const int a; // 无初始化器：C 允许，C++ 错误
```

### 跨越声明语句的 goto 语句

在 C 中，goto 语句可以跳过带初始化器的声明语句，但在 C++ 中不允许。
```c
goto line; // C 允许，C++ 错误
{
    int a = 42;
    line: printf("%d", a);
}
```

### 在函数声明中定义结构体

C 允许将结构体的定义放在函数的声明中：
```c
struct S { int x, y; } f(void) {
    struct S result = {1, 2};
    return result;
}
```
……甚至放在参数列表中：
```c
void f( struct S { int x, y; } a);
```

显然这样做会让程序变得更加晦涩，我们不太推荐。

### 旧式（K&R 风格）函数定义

在 C 中，函数参数的类型可以和函数的声明分离开来：
```c
int max(a, b)
    int a;
    int b;
    {
    return a > b ? a : b;
}
```
这被称为旧式函数定义，它等价于这样的新式函数定义：
```c
int max(int a, int b) {
    return a > b ? a : b;
}
```

旧式函数定义是一种不再被推荐的写法，而且即将被弃用。你只可能在一些很老的代码里见到这种写法，了解即可。

?> 以下介绍的特性都是 C99 标准引入的，它们可能不在老编译器上支持。

### 可变长数组（C99）

不同于 C++，C 在声明数组时允许它的大小不是常量（前提是该数组拥有自动存储期）：
```c
int n;
scanf("%d", &n);
int a[n]; // 大小不是常量，C 中 OK 但 C++ 中不允许
```
这种数组称为可变长数组（Variable Length Array, VLA）。此时，作用于 VLA 的 sizeof 表达式也不一定是常量了；sizeof 表达式会对 VLA 类型的操作数求值，并在运行时计算 VLA 的大小。

亦存在指向 VLA 的指针。

> 正因为 C 中 VLA 的存在，许多编译器也不严格地允许 C++ 中使用 VLA（如 g++）。但是我们应当尽量避免。

### 柔性数组（C99）

在 C 的结构体声明中，允许最后一个成员是不指定长度的数组，称为柔性数组：
```c
struct S {
    int data;
    char d[];
};
```
对于非动态存储期的 `S` 类型结构体，柔性数组成员如同其不存在：
```c
struct S a = {42};
struct S b = {42, {'A'}}; // 错误：如同柔性数组不存在
a.d[0] = 'A';             // 此时访问柔性数组成员是未定义行为
sizeof(struct S);         // 相当于 sizeof(int)，柔性数组此时不占用大小
```
但是，你可以在动态分配内存时为柔性数组提供存储空间：
```c
struct S* ptr1 = malloc(sizeof(struct S) + 30); // 相当于拥有成员 char d[30];
struct S* ptr2 = malloc(sizeof(struct S) + 50); // 相当于拥有成员 char d[50];
ptr1->d[0] = 'A'; // OK
```
但在结构体赋值时，仍然不考虑柔性数组的存在：
```c
*ptr2 = *ptr1; // 只赋值了 ptr2->data，ptr2->d 中的元素维持原样
```

### `restrict` 关键字（C99）

`restrict` 关键字只能在指针声明中出现（注意是在 `*` 的后面）：
```sdsc
*基类型*&#42; restrict *指针名* **直接初始化器**;
```
比如：
```c
int a;
int* restrict p = &a;
```
`restrict` 关键字指明：若其限定的指针 `p` 指向了变量 `a`，则任何对 `a` 的写入操作都必须经由 `p`。也就是说，此时任何不通过 `p` 而对 `a` 做修改都是未定义行为。这样的限制允许编译器做更多的优化。

### “数组做形参”的额外语法（C99）

在 C 中，数组传入形参依然会转换到指针：
```c
void f(int a[10]) {
    a; // 类型为 int* 的指针 
}
```
但 C 可以让这个转换结果带 `const` 限定，即转换到 `T* const` 类型（C++不存在此类语法）：
```c
void f(int a[const 10]) {
    a; // 类型为 int* const，即指向 int 的只读指针
}
```

类似地，C 还可以让转换结果带 `restrict` 限定：
```c
void f(int a[restrict 10]) {
    a; // int* restrict 类型
}
```

C 还可以在编译期间检查传入数组的大小，并限定某个参数的最小大小。比如：
```c
// 限定传入 f 的参数 a 是一个数组，且至少有 10 个元素
void f(int a[static 10]) {
    a; // 仍然转换到 int*
}
```
这样可以提示编译器做更多的优化。

由于在 C 语言中，数组参数的大小信息最终会被丢弃，所以大小这个值仅仅起到提示作用。比如：
```c
void f(int a[10]);
```
提示程序员，函数 `f` 的参数应当是一个 `int[10]` 类型的数组，传入其它长度的数组可能会出错。（然而事实上这个参数类型只是 `int*`。）C 还提供了一种语法，可以提示程序员这里的数组可以是任意长度的：
```c
void f(int a[*]);
```
但是这实际上和上面的写法一点区别也没有。

### 复合字面量（C99）

C 中还提供一种新的字面量，称为复合字面量。它允许你创建一个数组或结构体字面量：
```sdsc
(*数组/结构体类型标识*){*初始化值列表*}
```
比如
```c
(int[4]){1, 2, 3, 4}
```
创建了一个 `int[4]` 类型的数组，其中的四个元素分别为 `1` `2` `3` `4`。下面这个例子展示了创建结构体字面量，它可以减少一定的代码量：
```c
// 结构体：坐标
struct Coordinate {
    int x, y;
};
// 返回原点，只需一句 return
struct Coordinate getOrigin() {
    return (struct Coordinate){0, 0};
};
```

### 指派初始化（C99）

在 C 中，数组和结构体还允许一种特殊的初始化方法，称为指派初始化。用结构体举例：
```c
struct Coordinate {
    int x, y, z;
};
struct Coordinate a = {
    .y = 2,
    .x = 1,
    .z = 3
};
```
这里采用指派初始化结构体 `a`。其中 `a` 的 `y` 成员初始化为 `2`，`x` 成员初始化为 `1`，`z` 成员初始化为 `3`。即，结构体的指派初始化中，每一个初始化值由这样的形式（称为指派器）构成：
```sdsc
.*成员名* = *初始化值*
```
数组的指派初始化例如：
```c
int a[10] = {
    [0] = 1,
    [1] = 2,
    [7] = 3,
    [8] = 4
};
```
这里，初始化 `a[0]` 为 `1`，`a[1]` 为 `2`，`a[7]` 为 `3`, `a[8]` 为 `4`。即，数组的指派初始化中，每一个初始化值由这样的形式构成：
```sdsc
[*下标*] = *初始化值*
```

> 指派初始化随后不带指派器的初始化初始化刚刚指派位置的下一个元素（成员）。（这句话又点绕，但我没找到更合适的说法。）意思就是：`int a[10] = {[7] = 3, 4, 5};` 中，初始化的是 `a[7]` `a[8]` 和 `a[9]`，即后面没有给出指派器的初始化接着 `[7]` 的位置往下走。

> C++20 中也提供了结构体的指派初始化（这是聚合初始化的一种），但它不允许乱序（初始化顺序不得和成员声明顺序不同），也不允许嵌套。

### `_Generic` 泛型选择（C11）

C 提供了 `_Generic` 这一关键字，它可以一定程度上模仿 C++ 的函数重载。
```sdsc
_Generic(*参数*, *关联列表*)
```
其中，`@*关联列表*@` 是一系列逗号分隔的：

<pre class="sdsc">
<x-or><i>类型名</i><hr>default</x-or>: <i>表达式</i>
</pre>

`_Generic` 相当于一个表达式，当传入 `@*参数*@` 类型和 `@*关联列表*@` 中的某一 `@*类型名*@` 匹配时，则运算这个 `@*类型名*@` 对应的 `@*表达式*@`；若没有匹配的 `@*类型名*@`，就执行 `default` 对应的 `@*表达式*@`（若有，否则编译错误）。 

比如：
```C
int         abs(int       n);
long       labs(long      n);
long long llabs(long long n);
#define ABS(n) _Generic((n), \
    int      :   abs(n),     \
    long     :  labs(n),     \
    long long: llabs(n)      \
)
int main() {
    ABS(3);   // 调用 abs(3)
    ABS(3LL); // 调用 llabs(3)
}
```

除了上述内容外，C 的额外语法还有：
- `_Atomic` 原子类型（作用类似 C++ 中 `std::atomic`）
- 原生复数运算支持（作用类似 C++ 中 `std::complex`）

## 不同特性

- 无参函数需显式指明 `void` （C++ 中不需要）
- 字符字面量为 `int` 类型（C++ 中 `char`）
- 字符串字面量为 `char[N]` 类型（C++ 中 `const char[N]`）
- 循环或分支的条件只能为表达式（C++ 中允许声明）
- 循环或分支的条件均隐式转换为 `int` （C++ 中为 `bool`）
- 结构体详述类型说明符必须给出（C++ 中可省略）
- 结构体不引入作用域（C++ 中引入）
- 关键字 `inline` 含义为优先内联（C++ 中为容许重复定义）
- 全局作用域只读变量拥有外部链接（C++ 中拥有内部链接）
- `_Noreturn`（C++ 中 `[[noreturn]]`）
- 布尔类型类型说明符为 `_Bool`（C++ 中 `bool`）
- 对齐相关关键字 `_Alignas` `_Alignof`（C++ 中 `alignas` `alignof`）
- 静态断言 `_Static_assert`（C++ 中 `static_assert`）
- 线程存储期 `_Thread_local`（C++ 中 `thread_local`）

### C99 前

- 无单行注释（现有）
- 隐式函数声明（现被弃用）
- 全局 `int` 类型说明符可省略（现必需）
- main 函数中 `return 0;` 必需（现可选）
- for 循环初始语句只能为表达式（现允许声明）
- 复合语句中声明必须出现在开头（现允许任意位置）