# 其它小问题

最后，继承中有一些小的语法限制和要求。我简单过一下：

## 不会被继承的成员函数

基类的**构造函数**不会被继承。如果有可访问的（公开的、非 `=delete` 的）基类的**复制赋值运算符重载**，那么它也不会被继承。基类的**析构函数**不会被继承。

不继承构造函数的原因是：如果允许，那么派生类部分成员则是潜在的未初始化状态。这被认为是危险的，所以要求代码编写者需要手动指明派生类的构造函数，并且在初始化列表中将派生成员和基类的初始化方法指明。

不继承后两者的原因是：如果基类有可访问的对应函数，那么编译器总是会尝试隐式生成派生类的对应函数，而无需从基类继承它。

### 通过 `using` 声明继承构造函数（选读）

尽管如此，在一些场合为了减少不必要的代码，C++ 也允许继承构造函数。它的思路则是通过 [`using` 声明](ch07/inheritance/about_member_name#类作用域下的-using-声明（选读）)，将基类的构造函数导出到派生类。其写法是：
```cpp
struct Base {
    Base(int) { }
    Base(const char *) { }
};
struct Derived : Base {
    using Base::Base; // 将基类中的构造函数 Base 全数导入进来
};
int main() {
    Derived d1(42), d2("hi"); // 使用继承的构造函数
}
```

当使用继承的构造函数时，派生类部分成员被默认初始化。如果派生类部分成员无法默认初始化，则编译错误。继承基类构造函数无关乎 `using` 声明的可访问性。

## 重申隐式函数

因为派生类不继承构造函数、复制赋值和析构函数，所以编译器生成隐式默认构造和隐式复制构造的条件与一般类无异。在这里，我们总结一下带有继承语法时，编译器的这些隐式函数的生成规则：

当：
- 派生类无任何构造函数，且
- 基类和派生类各成员可以默认初始化

则派生类生成隐式默认构造函数，其效果是默认初始化基类及派生类各成员。

当：
- 派生类无自定义的复制构造函数，且
- 基类和派生类各成员可以复制初始化

则派生类生成隐式复制构造函数，其效果是复制初始化基类和派生类各成员。

当：
- 派生类无自定义的复制赋值重载，且
- 基类和派生类均有可访问的复制赋值重载

则派生类生成隐式复制赋值运算符重载，其效果是对基类和派生类各成员调用复制赋值重载。

当：
- 派生类无自定义的析构函数，且
- 基类和派生类均有可访问的析构函数

则派生类生成隐式析构函数，其效果是：对派生类各成员和基类调用析构函数（若有）。

始终注意，析构函数的调用顺序永远和构造函数相反。

### 三之原则

这里还剩下些许篇幅，我简单介绍一下所谓的“三之原则”。这条原则并不是语法规则，而是一个良好的编码习惯。它是这样说的：如果需要自己定义复制构造函数、复制赋值重载或析构函数的其中一个，则这三个尽可能都要被手动定义。也就是说，这三者要么都不用（采用隐式生成的），要么都得写。这条原则保证了所有内存的管理都是妥当的，一定程度上避免了内存泄漏的可能。

### 零之原则

零之原则和三之原则相反，它是说如果你不需要手动管理内存（比如在构造函数里执行 `new`），那么就尽可能地使用编译器生成的隐式复制构造、隐式复制赋值和隐式析构。这保证了代码的简洁性和可复用性。